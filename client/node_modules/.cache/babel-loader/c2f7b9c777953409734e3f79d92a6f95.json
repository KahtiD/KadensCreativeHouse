{"ast":null,"code":"/*\n * fitty v2.2.6 - Snugly resizes text to fit its parent container\n * Copyright (c) 2018 Rik Schennink <hello@rikschennink.nl> (http://rikschennink.nl/)\n */\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nexports.default = function (w) {\n  // no window, early exit\n  if (!w) {\n    return;\n  } // node list to array helper method\n\n\n  var toArray = function toArray(nl) {\n    return [].slice.call(nl);\n  }; // states\n\n\n  var DrawState = {\n    IDLE: 0,\n    DIRTY_CONTENT: 1,\n    DIRTY_LAYOUT: 2,\n    DIRTY: 3\n  }; // all active fitty elements\n\n  var fitties = []; // group all redraw calls till next frame, we cancel each frame request when a new one comes in. If no support for request animation frame, this is an empty function and supports for fitty stops.\n\n  var redrawFrame = null;\n  var requestRedraw = 'requestAnimationFrame' in w ? function () {\n    w.cancelAnimationFrame(redrawFrame);\n    redrawFrame = w.requestAnimationFrame(function () {\n      redraw(fitties.filter(function (f) {\n        return f.dirty;\n      }));\n    });\n  } : function () {}; // sets all fitties to dirty so they are redrawn on the next redraw loop, then calls redraw\n\n  var redrawAll = function redrawAll(type) {\n    return function () {\n      fitties.forEach(function (f) {\n        f.dirty = type;\n      });\n      requestRedraw();\n    };\n  }; // redraws fitties so they nicely fit their parent container\n\n\n  var redraw = function redraw(fitties) {\n    // getting info from the DOM at this point should not trigger a reflow, let's gather as much intel as possible before triggering a reflow\n    // check if styles of all fitties have been computed\n    fitties.filter(function (f) {\n      return !f.styleComputed;\n    }).forEach(function (f) {\n      f.styleComputed = computeStyle(f);\n    }); // restyle elements that require pre-styling, this triggers a reflow, please try to prevent by adding CSS rules (see docs)\n\n    fitties.filter(shouldPreStyle).forEach(applyStyle); // we now determine which fitties should be redrawn\n\n    var fittiesToRedraw = fitties.filter(shouldRedraw); // we calculate final styles for these fitties\n\n    fittiesToRedraw.forEach(calculateStyles); // now we apply the calculated styles from our previous loop\n\n    fittiesToRedraw.forEach(function (f) {\n      applyStyle(f);\n      markAsClean(f);\n    }); // now we dispatch events for all restyled fitties\n\n    fittiesToRedraw.forEach(dispatchFitEvent);\n  };\n\n  var markAsClean = function markAsClean(f) {\n    return f.dirty = DrawState.IDLE;\n  };\n\n  var calculateStyles = function calculateStyles(f) {\n    // get available width from parent node\n    f.availableWidth = f.element.parentNode.clientWidth; // the space our target element uses\n\n    f.currentWidth = f.element.scrollWidth; // remember current font size\n\n    f.previousFontSize = f.currentFontSize; // let's calculate the new font size\n\n    f.currentFontSize = Math.min(Math.max(f.minSize, f.availableWidth / f.currentWidth * f.previousFontSize), f.maxSize); // if allows wrapping, only wrap when at minimum font size (otherwise would break container)\n\n    f.whiteSpace = f.multiLine && f.currentFontSize === f.minSize ? 'normal' : 'nowrap';\n  }; // should always redraw if is not dirty layout, if is dirty layout, only redraw if size has changed\n\n\n  var shouldRedraw = function shouldRedraw(f) {\n    return f.dirty !== DrawState.DIRTY_LAYOUT || f.dirty === DrawState.DIRTY_LAYOUT && f.element.parentNode.clientWidth !== f.availableWidth;\n  }; // every fitty element is tested for invalid styles\n\n\n  var computeStyle = function computeStyle(f) {\n    // get style properties\n    var style = w.getComputedStyle(f.element, null); // get current font size in pixels (if we already calculated it, use the calculated version)\n\n    f.currentFontSize = parseInt(style.getPropertyValue('font-size'), 10); // get display type and wrap mode\n\n    f.display = style.getPropertyValue('display');\n    f.whiteSpace = style.getPropertyValue('white-space');\n  }; // determines if this fitty requires initial styling, can be prevented by applying correct styles through CSS\n\n\n  var shouldPreStyle = function shouldPreStyle(f) {\n    var preStyle = false; // if we already tested for prestyling we don't have to do it again\n\n    if (f.preStyleTestCompleted) {\n      return false;\n    } // should have an inline style, if not, apply\n\n\n    if (!/inline-/.test(f.display)) {\n      preStyle = true;\n      f.display = 'inline-block';\n    } // to correctly calculate dimensions the element should have whiteSpace set to nowrap\n\n\n    if (f.whiteSpace !== 'nowrap') {\n      preStyle = true;\n      f.whiteSpace = 'nowrap';\n    } // we don't have to do this twice\n\n\n    f.preStyleTestCompleted = true;\n    return preStyle;\n  }; // apply styles to single fitty\n\n\n  var applyStyle = function applyStyle(f) {\n    // remember original style, we need this to restore the fitty style when unsubscribing\n    if (!f.originalStyle) {\n      f.originalStyle = f.element.getAttribute('style') || '';\n    } // set the new style to the original style plus the fitty styles\n\n\n    f.element.style.cssText = f.originalStyle + ';white-space:' + f.whiteSpace + ';display:' + f.display + ';font-size:' + f.currentFontSize + 'px';\n  }; // dispatch a fit event on a fitty\n\n\n  var dispatchFitEvent = function dispatchFitEvent(f) {\n    f.element.dispatchEvent(new CustomEvent('fit', {\n      detail: {\n        oldValue: f.previousFontSize,\n        newValue: f.currentFontSize,\n        scaleFactor: f.currentFontSize / f.previousFontSize\n      }\n    }));\n  }; // fit method, marks the fitty as dirty and requests a redraw (this will also redraw any other fitty marked as dirty)\n\n\n  var fit = function fit(f, type) {\n    return function () {\n      f.dirty = type;\n      requestRedraw();\n    };\n  }; // add a new fitty, does not redraw said fitty\n\n\n  var subscribe = function subscribe(f) {\n    // this is a new fitty so we need to validate if it's styles are in order\n    f.newbie = true; // because it's a new fitty it should also be dirty, we want it to redraw on the first loop\n\n    f.dirty = true; // we want to be able to update this fitty\n\n    fitties.push(f);\n  }; // remove an existing fitty\n\n\n  var unsubscribe = function unsubscribe(f) {\n    return function () {\n      // remove from fitties array\n      fitties = fitties.filter(function (_) {\n        return _.element !== f.element;\n      }); // stop observing DOM\n\n      if (f.observeMutations) {\n        f.observer.disconnect();\n      } // reset font size to inherited size\n\n\n      f.element.style.cssText = f.originalStyle;\n    };\n  };\n\n  var observeMutations = function observeMutations(f) {\n    // no observing?\n    if (!f.observeMutations) {\n      return;\n    } // start observing mutations\n\n\n    f.observer = new MutationObserver(fit(f, DrawState.DIRTY_CONTENT)); // start observing\n\n    f.observer.observe(f.element, f.observeMutations);\n  }; // default mutation observer settings\n\n\n  var mutationObserverDefaultSetting = {\n    subtree: true,\n    childList: true,\n    characterData: true\n  }; // default fitty options\n\n  var defaultOptions = {\n    minSize: 16,\n    maxSize: 512,\n    multiLine: true,\n    observeMutations: 'MutationObserver' in w ? mutationObserverDefaultSetting : false\n  }; // array of elements in, fitty instances out\n\n  function fittyCreate(elements, options) {\n    // set options object\n    var fittyOptions = _extends({}, defaultOptions, options); // create fitties\n\n\n    var publicFitties = elements.map(function (element) {\n      // create fitty instance\n      var f = _extends({}, fittyOptions, {\n        // internal options for this fitty\n        element: element\n      }); // register this fitty\n\n\n      subscribe(f); // should we observe DOM mutations\n\n      observeMutations(f); // expose API\n\n      return {\n        element: element,\n        fit: fit(f, DrawState.DIRTY),\n        unsubscribe: unsubscribe(f)\n      };\n    }); // call redraw on newly initiated fitties\n\n    requestRedraw(); // expose fitties\n\n    return publicFitties;\n  } // fitty creation function\n\n\n  function fitty(target) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}; // if target is a string\n\n    return typeof target === 'string' ? // treat it as a querySelector\n    fittyCreate(toArray(document.querySelectorAll(target)), options) : // create single fitty\n    fittyCreate([target], options)[0];\n  } // handles viewport changes, redraws all fitties, but only does so after a timeout\n\n\n  var resizeDebounce = null;\n\n  var onWindowResized = function onWindowResized() {\n    w.clearTimeout(resizeDebounce);\n    resizeDebounce = w.setTimeout(redrawAll(DrawState.DIRTY_LAYOUT), fitty.observeWindowDelay);\n  }; // define observe window property, so when we set it to true or false events are automatically added and removed\n\n\n  var events = ['resize', 'orientationchange'];\n  Object.defineProperty(fitty, 'observeWindow', {\n    set: function set(enabled) {\n      var method = (enabled ? 'add' : 'remove') + 'EventListener';\n      events.forEach(function (e) {\n        w[method](e, onWindowResized);\n      });\n    }\n  }); // fitty global properties (by setting observeWindow to true the events above get added)\n\n  fitty.observeWindow = true;\n  fitty.observeWindowDelay = 100; // public fit all method, will force redraw no matter what\n\n  fitty.fitAll = redrawAll(DrawState.DIRTY); // export our fitty function, we don't want to keep it to our selves\n\n  return fitty;\n}(typeof window === 'undefined' ? null : window);","map":null,"metadata":{},"sourceType":"script"}